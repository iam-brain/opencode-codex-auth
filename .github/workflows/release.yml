name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  actions: read
  contents: read

jobs:
  verify:
    name: Verify release candidate
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      actions: read
      contents: read
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: "20.x"
          cache: npm
      - name: Pin npm version from packageManager
        run: |
          set -euo pipefail
          PKG_MANAGER="$(node -p "JSON.parse(require('node:fs').readFileSync('package.json','utf8')).packageManager")"
          case "${PKG_MANAGER}" in
            npm@*) NPM_VERSION="${PKG_MANAGER#npm@}" ;;
            *) echo "Unsupported packageManager: ${PKG_MANAGER}" >&2; exit 1 ;;
          esac
          corepack enable || true
          corepack prepare "npm@${NPM_VERSION}" --activate || true
          if [ "$(npm --version)" != "${NPM_VERSION}" ]; then
            echo "npm version mismatch after corepack, falling back to npm install -g"
            npm install -g "npm@${NPM_VERSION}"
          fi
          test "$(npm --version)" = "${NPM_VERSION}"
      - name: Ensure tagged commit matches default branch tip
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail
          BRANCH="${DEFAULT_BRANCH:-main}"
          git fetch --no-tags origin "${BRANCH}"
          TAGGED_SHA="$(git rev-parse "${GITHUB_SHA}")"
          BRANCH_HEAD_SHA="$(git rev-parse "origin/${BRANCH}")"
          test "${TAGGED_SHA}" = "${BRANCH_HEAD_SHA}"
      - name: Ensure required CI checks succeeded for tagged commit
        env:
          GH_TOKEN: ${{ github.token }}
          REQUIRED_CI_WORKFLOW: ci.yml
          REQUIRED_CI_JOBS_JSON: '["Verify on Node.js 20.x","Verify on Node.js 22.x","Package Smoke Test","Package Smoke Test (Windows)","Windows Runtime Hardening (Node.js 20.x)","Windows Runtime Hardening (Node.js 22.x)","Security Audit"]'
        run: |
          set -euo pipefail
          RUNS_JSON="$(gh run list \
            --repo "${GITHUB_REPOSITORY}" \
            --workflow "${REQUIRED_CI_WORKFLOW}" \
            --commit "${GITHUB_SHA}" \
            --event push \
            --limit 20 \
            --json databaseId,status,conclusion,headSha,createdAt,url)"
          export RUNS_JSON
          RUN_ID="$(node <<'NODE'
          const runs = JSON.parse(process.env.RUNS_JSON || "[]")
          const sha = process.env.GITHUB_SHA
          const matching = Array.isArray(runs)
            ? runs.filter((run) => run && run.headSha === sha)
            : []
          matching.sort((left, right) => String(right.createdAt).localeCompare(String(left.createdAt)))
          const latest = matching[0]?.databaseId
          if (!latest) {
            console.error(`No ci.yml push run found for ${sha}.`)
            process.exit(1)
          }
          process.stdout.write(String(latest))
          NODE
          )"

          DETAILS_JSON=""
          STATUS=""
          CONCLUSION=""
          for attempt in $(seq 1 120); do
            DETAILS_JSON="$(gh run view "${RUN_ID}" --repo "${GITHUB_REPOSITORY}" --json status,conclusion,jobs,url)"
            STATUS="$(node -e 'const details = JSON.parse(process.argv[1] || "{}"); process.stdout.write(String(details.status ?? ""))' "${DETAILS_JSON}")"
            CONCLUSION="$(node -e 'const details = JSON.parse(process.argv[1] || "{}"); process.stdout.write(String(details.conclusion ?? ""))' "${DETAILS_JSON}")"
            if [ "${STATUS}" = "completed" ]; then
              break
            fi
            sleep 10
          done
          if [ "${STATUS}" != "completed" ]; then
            echo "Timed out waiting for ci.yml run ${RUN_ID} to complete."
            exit 1
          fi

          export DETAILS_JSON
          node <<'NODE'
          const details = JSON.parse(process.env.DETAILS_JSON || "{}")
          if (details.status !== "completed" || details.conclusion !== "success") {
            throw new Error(
              `Latest ci.yml push run is not green: status=${details.status ?? "unknown"}, conclusion=${details.conclusion ?? "unknown"} ${details.url ?? ""}`.trim()
            )
          }
          const requiredJobs = JSON.parse(process.env.REQUIRED_CI_JOBS_JSON || "[]")
          const jobs = Array.isArray(details.jobs) ? details.jobs : []
          for (const requiredJob of requiredJobs) {
            const match = jobs.find((job) => job && job.name === requiredJob)
            if (!match) {
              throw new Error(`Required CI job missing in ci.yml run: ${requiredJob}`)
            }
            if (match.conclusion !== "success") {
              throw new Error(`Required CI job is not successful (${requiredJob}): ${match.conclusion ?? "unknown"}`)
            }
          }
          NODE
      - name: Ensure tag matches package version
        run: |
          set -euo pipefail
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          PACKAGE_VERSION="$(node -p "JSON.parse(require('node:fs').readFileSync('package.json','utf8')).version")"
          test "${TAG_VERSION}" = "${PACKAGE_VERSION}"
      - name: Install dependencies
        run: npm ci
      - name: Verify npm version
        run: npm --version
      - name: Run verify
        run: npm run verify
      - name: Pack release tarball
        run: |
          set -euo pipefail
          TARBALL="$(npm pack --silent)"
          test -f "${TARBALL}"
          mkdir -p release-artifact
          mv "${TARBALL}" release-artifact/
      - name: Upload release artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: npm-release-tarball
          path: release-artifact/*.tgz

  npm-publish:
    name: Publish to npm
    needs: verify
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: npm-release
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 1
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: "20.x"
          registry-url: "https://registry.npmjs.org"
          cache: npm
      - name: Pin npm version from packageManager
        run: |
          set -euo pipefail
          PKG_MANAGER="$(node -p "JSON.parse(require('node:fs').readFileSync('package.json','utf8')).packageManager")"
          case "${PKG_MANAGER}" in
            npm@*) NPM_VERSION="${PKG_MANAGER#npm@}" ;;
            *) echo "Unsupported packageManager: ${PKG_MANAGER}" >&2; exit 1 ;;
          esac
          corepack enable || true
          corepack prepare "npm@${NPM_VERSION}" --activate || true
          if [ "$(npm --version)" != "${NPM_VERSION}" ]; then
            echo "npm version mismatch after corepack, falling back to npm install -g"
            npm install -g "npm@${NPM_VERSION}"
          fi
          test "$(npm --version)" = "${NPM_VERSION}"
      - name: Download release artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          name: npm-release-tarball
          path: release-artifact
      - name: Publish to npm (Trusted Publishing, idempotent)
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -euo pipefail
          PKG_NAME="$(node -p "JSON.parse(require('node:fs').readFileSync('package.json','utf8')).name")"
          PKG_VERSION="$(node -p "JSON.parse(require('node:fs').readFileSync('package.json','utf8')).version")"
          if npm view "${PKG_NAME}@${PKG_VERSION}" version >/dev/null 2>&1; then
            echo "Package already published: ${PKG_NAME}@${PKG_VERSION}. Skipping npm publish."
            exit 0
          fi
          TARBALL="$(ls -1 ./release-artifact/*.tgz | head -n 1)"
          test -f "${TARBALL}"
          ORIGINAL_NODE_AUTH_TOKEN="${NODE_AUTH_TOKEN:-}"
          ORIGINAL_NPM_TOKEN="${NPM_TOKEN:-}"
          OIDC_LOG="$(mktemp)"
          TOKEN_LOG="$(mktemp)"

          # Attempt OIDC trusted publishing first.
          if [ -n "${NPM_CONFIG_USERCONFIG:-}" ] && [ -f "${NPM_CONFIG_USERCONFIG}" ]; then
            rm -f "${NPM_CONFIG_USERCONFIG}"
          fi
          rm -f "${HOME}/.npmrc" || true
          unset NODE_AUTH_TOKEN NPM_TOKEN NPM_CONFIG_USERCONFIG || true
          set +e
          npm publish "${TARBALL}" --access public --provenance >"${OIDC_LOG}" 2>&1
          OIDC_STATUS=$?
          set -e
          if [ ${OIDC_STATUS} -eq 0 ]; then
            cat "${OIDC_LOG}"
            rm -f "${OIDC_LOG}" "${TOKEN_LOG}"
            exit 0
          fi

          # If OIDC isn't configured for this package, retry once with token auth when available.
          if grep -Eiq "ENEEDAUTH|need auth" "${OIDC_LOG}"; then
            FALLBACK_TOKEN="${ORIGINAL_NODE_AUTH_TOKEN:-${ORIGINAL_NPM_TOKEN:-}}"
            if [ -n "${FALLBACK_TOKEN}" ]; then
              echo "OIDC publish unavailable; retrying with token auth."
              export NODE_AUTH_TOKEN="${FALLBACK_TOKEN}"
              export NPM_CONFIG_USERCONFIG="${RUNNER_TEMP:-/tmp}/npmrc.publish"
              umask 077
              printf "//registry.npmjs.org/:_authToken=%s\n" "${NODE_AUTH_TOKEN}" > "${NPM_CONFIG_USERCONFIG}"
              chmod 600 "${NPM_CONFIG_USERCONFIG}"
              set +e
              npm publish "${TARBALL}" --access public --provenance >"${TOKEN_LOG}" 2>&1
              TOKEN_STATUS=$?
              set -e
              if [ ${TOKEN_STATUS} -eq 0 ]; then
                cat "${TOKEN_LOG}"
                rm -f "${OIDC_LOG}" "${TOKEN_LOG}" "${NPM_CONFIG_USERCONFIG}"
                exit 0
              fi
              cat "${TOKEN_LOG}"
              rm -f "${OIDC_LOG}" "${TOKEN_LOG}" "${NPM_CONFIG_USERCONFIG}"
              exit ${TOKEN_STATUS}
            fi
            echo "OIDC publish failed and no token fallback is configured."
          fi

          cat "${OIDC_LOG}"
          rm -f "${OIDC_LOG}" "${TOKEN_LOG}"
          exit ${OIDC_STATUS}

  release:
    name: Create GitHub Release
    needs: npm-publish
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Create release (idempotent)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          echo "Tag: ${TAG}"

          if gh release view "${TAG}" --repo "${GITHUB_REPOSITORY}" >/dev/null 2>&1; then
            echo "Release already exists for ${TAG}; skipping."
            exit 0
          fi

          gh release create "${TAG}" \
            --repo "${GITHUB_REPOSITORY}" \
            --verify-tag \
            --generate-notes
